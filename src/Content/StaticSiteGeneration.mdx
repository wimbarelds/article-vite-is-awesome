## Static Site Generation

At this point, I had a React app with routing and wanted to add pre-rendering/static site
generation. You might wonder why a slide deck needs static site generation. That's a good question,
but that reason isn't relevant for this article.

The challenge was that most mature and popular static site generation solutions for React require
you to structure your application in a specific way, often involving file-based routing or their
proprietary routing solutions. While there's nothing wrong with these approaches, I already had a
functional React app with routing exactly as I wanted it. I didn't want to change my application; I
only wanted to modify the build process.

So, as I often do when I have enough time, I decided to find my own solution. A
[Medium article](https://medium.com/@singhdharmu89/how-to-implement-ssr-ssg-in-a-react-19-app-using-vite-with-react-router-dom-without-plugins-1646adce99c1)
provided some guidance, but I believed I could improve upon it.

### Traditional Static Site Generation

The established method for static site generation with Vite, without a full framework, typically
involves these steps:

1.  **Client Build:** Create a production build where `createRoot(el).render(<App />)` is replaced
    with `hydrateRoot(el, <App />)`.
2.  **Server Build:** Create a server build that exports a
    `function render(url: string): Promise<string>`, which calls `renderToString(<App />)`.
3.  **Prerender Script:** Execute a `prerender.js` file that combines the output of both build
    artifacts to generate an HTML file for each route you want prerendered.

Your build command often ends up looking something like this:

```bash
npm run build:client && npm run build:server && node generate-static.js
```

### New and Improved Static Site Generation

Running several separate commands sequentially to create a build felt clunky to me. Thanks to
recently added Vite features â€“ specifically the **Environment API** and the **`buildApp` hook** - we
can create a more cohesive process.

The following configuration is larger than the previous examples, but it remains quite easy to
understand if you go line-by-line:

```ts
const baseConfig: UserConfig = {
  plugins: [
    react(),
    // other plugins
  ],
};

export default defineConfig(({ command }): UserConfig => {
  if (command !== 'build') return baseConfig;

  return {
    ...baseConfig,
    resolve: {
      // Allow us to use a different entry point that uses hydrateRoot
      alias: { '/src/main.tsx': '/src/entry-client.tsx' },
    },
    // Define a client and server environment
    environments: {
      client: { consumer: 'client' },
      server: {
        consumer: 'server',
        build: {
          emptyOutDir: false, // avoid deleting the client build
          copyPublicDir: false, // we dont want anything except the 'server' js
          // tell vite the entry-point for the server environment
          rollupOptions: { input: 'src/entry-server.tsx' },
        },
      },
    },
    builder: {
      buildApp: async (builder) => {
        // Do the build for server and client
        await builder.build(builder.environments.client);
        await builder.build(builder.environments.server);

        // Figure out where the files are
        const serverJsPath = path.resolve(process.cwd(), 'dist/entry-server.js');
        const indexHtmlPath = path.resolve(process.cwd(), 'dist/index.html');

        // Read or import them
        const renderFn = await import(serverJsPath).then((module) => module.render);
        const indexHtml = fs.readFileSync(indexHtmlPath, { encoding: 'utf-8' });

        // Prerender everything
        const { prerender } = await import('./src/prerender');
        await prerender(renderFn, indexHtml);
      },
    },
  };
});
```

This configuration creates a remarkably cohesive build process. We simply define two environments,
and the **`buildApp` hook** allows us to control their build processes. We can then easily add code
to prerender all our routes. Now, a single `npm run build` command handles everything in one go.
